<!DOCTYPE html>
<html lang="cs">
<head>
  <meta charset="UTF-8">
  <title>Síň megalovců 3D – Galerie legend</title>
  <style>
    body {
      margin: 0;
      overflow: hidden;
      font-family: system-ui, -apple-system, BlinkMacSystemFont, "Segoe UI", sans-serif;
      background: #000;
      color: #fff;
    }
    #overlay {
      position: fixed;
      inset: 0;
      display: flex;
      align-items: center;
      justify-content: center;
      background: radial-gradient(circle at top, rgba(80,80,120,0.6), rgba(0,0,0,0.95));
      color: #fff;
      z-index: 10;
      cursor: pointer;
      flex-direction: column;
      text-align: center;
    }
    #overlay h1 {
      letter-spacing: 0.15em;
      text-transform: uppercase;
      font-weight: 600;
      margin-bottom: 0.4em;
    }
    #overlay p {
      opacity: 0.85;
      max-width: 480px;
    }
    #info {
      position: fixed;
      top: 10px;
      left: 10px;
      z-index: 5;
      background: rgba(0,0,0,0.55);
      padding: 8px 12px;
      border-radius: 4px;
      font-size: 13px;
      backdrop-filter: blur(6px);
      border: 1px solid rgba(255,255,255,0.08);
    }
  </style>
</head>
<body>
<div id="overlay">
  <h1>SÍŇ MEGALOVCŮ</h1>
  <p>Klikni pro vstup do galerie legend. Ovládání: WASD = pomalá chůze, myš = rozhlížení, Esc = kurzor.</p>
</div>
<div id="info">
  Prohlídka: WASD = chůze, myš = rozhlížení
</div>

<script type="module">
  import * as THREE from './three.module.js';
  import { PointerLockControls } from './PointerLockControls.js';

  // ===== SCÉNA =====
  const scene = new THREE.Scene();
  scene.background = new THREE.Color(0x050509);
  scene.fog = new THREE.FogExp2(0x050509, 0.03);

  const camera = new THREE.PerspectiveCamera(
    70,
    window.innerWidth / window.innerHeight,
    0.1,
    200
  );

  const renderer = new THREE.WebGLRenderer({ antialias: true });
  renderer.setSize(window.innerWidth, window.innerHeight);
  renderer.shadowMap.enabled = true;
  renderer.shadowMap.type = THREE.PCFSoftShadowMap;
  document.body.appendChild(renderer.domElement);

  // ===== SVĚTLA =====
  const hemiLight = new THREE.HemisphereLight(0x8899ff, 0x202020, 0.7);
  scene.add(hemiLight);

  const mainSpot = new THREE.SpotLight(0xffffff, 1.3, 90, Math.PI / 4, 0.4, 1);
  mainSpot.position.set(0, 14, 0);
  mainSpot.castShadow = true;
  scene.add(mainSpot);

  const accentLeft = new THREE.PointLight(0x4466ff, 0.7, 30);
  accentLeft.position.set(-9, 4, -9);
  scene.add(accentLeft);

  const accentRight = new THREE.PointLight(0xaa66ff, 0.7, 30);
  accentRight.position.set(9, 4, -9);
  scene.add(accentRight);

  // ===== ROZMĚRY MÍSTNOSTI =====
  const roomWidth = 24;
  const roomDepth = 34;
  const roomHeight = 9;

  // ===== TEXTURY =====
  const loader = new THREE.TextureLoader();

  function setupTex(tex, repX, repY) {
    tex.wrapS = tex.wrapT = THREE.RepeatWrapping;
    tex.repeat.set(repX, repY);
    tex.minFilter = THREE.LinearMipMapLinearFilter;
    tex.anisotropy = renderer.capabilities.getMaxAnisotropy();
    return tex;
  }

  const floorTex = setupTex(
    loader.load('https://ambientcg.com/get?file=Marble006_1K-JPG_Color.jpg'),
    4, 4
  );
  const wallTex = setupTex(
    loader.load('https://ambientcg.com/get?file=Concrete051_1K-JPG_Color.jpg'),
    3, 2
  );
  const ceilingTex = setupTex(
    loader.load('https://ambientcg.com/get?file=Metal034_1K-JPG_Color.jpg'),
    3, 3
  );

  const floorMaterial = new THREE.MeshStandardMaterial({
    map: floorTex,
    metalness: 0.8,
    roughness: 0.25
  });

  const wallMaterial = new THREE.MeshStandardMaterial({
    map: wallTex,
    metalness: 0.3,
    roughness: 0.8
  });

  const ceilingMaterial = new THREE.MeshStandardMaterial({
    map: ceilingTex,
    metalness: 0.4,
    roughness: 0.6
  });

  const trimBlue = new THREE.MeshStandardMaterial({
    color: 0x111122,
    emissive: new THREE.Color(0x3355ff),
    emissiveIntensity: 1.8,
    metalness: 0.8,
    roughness: 0.2
  });

  const trimPurple = new THREE.MeshStandardMaterial({
    color: 0x111122,
    emissive: new THREE.Color(0xaa55ff),
    emissiveIntensity: 1.6,
    metalness: 0.8,
    roughness: 0.2
  });

  // ===== PODLAHA =====
  const floorGeo = new THREE.PlaneGeometry(roomWidth, roomDepth);
  const floor = new THREE.Mesh(floorGeo, floorMaterial);
  floor.rotation.x = -Math.PI / 2;
  floor.receiveShadow = true;
  scene.add(floor);

  const centerTileGeo = new THREE.PlaneGeometry(roomWidth * 0.6, roomDepth * 0.6);
  const centerTileMat = new THREE.MeshStandardMaterial({
    color: 0x101015,
    metalness: 0.6,
    roughness: 0.4
  });
  const centerTile = new THREE.Mesh(centerTileGeo, centerTileMat);
  centerTile.rotation.x = -Math.PI / 2;
  centerTile.position.y = 0.01;
  centerTile.receiveShadow = true;
  scene.add(centerTile);

  // ===== STROP =====
  const ceilingGeo = new THREE.PlaneGeometry(roomWidth, roomDepth);
  const ceiling = new THREE.Mesh(ceilingGeo, ceilingMaterial);
  ceiling.rotation.x = Math.PI / 2;
  ceiling.position.y = roomHeight;
  ceiling.receiveShadow = true;
  scene.add(ceiling);

  const ceilingPanelMat = new THREE.MeshStandardMaterial({
    color: 0x111118,
    emissive: new THREE.Color(0x334477),
    emissiveIntensity: 0.7,
    metalness: 0.6,
    roughness: 0.3
  });

  function createCeilingPanel(x, z, w, d) {
    const geo = new THREE.PlaneGeometry(w, d);
    const mesh = new THREE.Mesh(geo, ceilingPanelMat);
    mesh.rotation.x = Math.PI / 2;
    mesh.position.set(x, roomHeight - 0.02, z);
    scene.add(mesh);
    return mesh;
  }

  createCeilingPanel(0, 0, roomWidth * 0.5, roomDepth * 0.25);
  createCeilingPanel(0, -roomDepth * 0.2, roomWidth * 0.4, roomDepth * 0.18);
  createCeilingPanel(0, roomDepth * 0.2, roomWidth * 0.4, roomDepth * 0.18);

  // ===== KOLIZNÍ OBJEKTY =====
  const colliders = [];
  const colliderBoxes = [];

  function addCollider(mesh) {
    colliders.push(mesh);
    const box = new THREE.Box3().setFromObject(mesh);
    colliderBoxes.push(box);
  }

  function updateColliderBox(index) {
    colliderBoxes[index].setFromObject(colliders[index]);
  }

  function createWall(width, height, depth, x, y, z, rotY = 0) {
    const geo = new THREE.BoxGeometry(width, height, depth);
    const mesh = new THREE.Mesh(geo, wallMaterial);
    mesh.position.set(x, y, z);
    mesh.rotation.y = rotY;
    mesh.castShadow = true;
    mesh.receiveShadow = true;
    scene.add(mesh);
    addCollider(mesh);
    return mesh;
  }

  // obvodové stěny
  createWall(roomWidth, roomHeight, 0.6, 0, roomHeight / 2, -roomDepth / 2);
  createWall(roomWidth, roomHeight, 0.6, 0, roomHeight / 2, roomDepth / 2);
  createWall(roomDepth, roomHeight, 0.6, -roomWidth / 2, roomHeight / 2, 0, Math.PI / 2);
  createWall(roomDepth, roomHeight, 0.6, roomWidth / 2, roomHeight / 2, 0, Math.PI / 2);

  const pillarMat = new THREE.MeshStandardMaterial({
    color: 0x181820,
    metalness: 0.5,
    roughness: 0.5
  });

  function createPillar(x, z) {
    const geo = new THREE.BoxGeometry(1.2, roomHeight, 1.2);
    const mesh = new THREE.Mesh(geo, pillarMat);
    mesh.position.set(x, roomHeight / 2, z);
    mesh.castShadow = true;
    mesh.receiveShadow = true;
    scene.add(mesh);
    addCollider(mesh);
    return mesh;
  }

  createPillar(-roomWidth / 2 + 1, -roomDepth / 2 + 1);
  createPillar(roomWidth / 2 - 1, -roomDepth / 2 + 1);
  createPillar(-roomWidth / 2 + 1, roomDepth / 2 - 1);
  createPillar(roomWidth / 2 - 1, roomDepth / 2 - 1);

  function createTrim(x, y, z, w, h, d, material) {
    const geo = new THREE.BoxGeometry(w, h, d);
    const mesh = new THREE.Mesh(geo, material);
    mesh.position.set(x, y, z);
    mesh.castShadow = false;
    mesh.receiveShadow = false;
    scene.add(mesh);
    return mesh;
  }

  createTrim(0, 0.05, -roomDepth / 2 + 0.3, roomWidth, 0.1, 0.2, trimBlue);
  createTrim(0, 0.05, roomDepth / 2 - 0.3, roomWidth, 0.1, 0.2, trimPurple);
  createTrim(-roomWidth / 2 + 0.3, 0.05, 0, roomDepth, 0.1, 0.2, trimBlue);
  createTrim(roomWidth / 2 - 0.3, 0.05, 0, roomDepth, 0.1, 0.2, trimPurple);

  // ===== DATA =====
  const leaderboard = [
    { name: 'MegaHunterCZ', score: 98765 },
    { name: 'ShadowWolf', score: 87654 },
    { name: 'PixelSlayer', score: 76543 },
    { name: 'NoScopeNinja', score: 65432 },
    { name: 'LuckyShot', score: 54321 }
  ];

  const hallOfFame = [
    'Hall of Fame',
    '-----------------',
    'MegaHunterCZ – 12x #1',
    'ShadowWolf – 9x top 3',
    'PixelSlayer – 7x MVP'
  ];

  const streaks = [
    'Nejdelší série',
    '-----------------',
    'NoScopeNinja – 47',
    'LuckyShot – 39',
    'ShadowWolf – 34'
  ];

  // ===== TEXT PANELY =====
  const textCanvasCache = {};

  function createTextTexture(lines, width = 512, height = 512) {
    const key = lines.join('\n');
    if (textCanvasCache[key]) return textCanvasCache[key];

    const canvas = document.createElement('canvas');
    canvas.width = width;
    canvas.height = height;
    const ctx = canvas.getContext('2d');

    const gradient = ctx.createLinearGradient(0, 0, 0, height);
    gradient.addColorStop(0, '#151728');
    gradient.addColorStop(1, '#05060b');
    ctx.fillStyle = gradient;
    ctx.fillRect(0, 0, width, height);

    ctx.strokeStyle = 'rgba(200,200,255,0.6)';
    ctx.lineWidth = 4;
    ctx.strokeRect(18, 18, width - 36, height - 36);

    ctx.fillStyle = '#ffffff';
    ctx.textAlign = 'center';
    ctx.textBaseline = 'top';

    let y = 40;
    for (let i = 0; i < lines.length; i++) {
      const line = lines[i];
      ctx.font = i === 0 ? 'bold 40px "Segoe UI", sans-serif' : '24px "Segoe UI", sans-serif';
      ctx.fillText(line, width / 2, y);
      y += i === 0 ? 52 : 34;
    }

    const texture = new THREE.CanvasTexture(canvas);
    texture.anisotropy = renderer.capabilities.getMaxAnisotropy();
    texture.needsUpdate = true;
    textCanvasCache[key] = texture;
    return texture;
  }

  function createPanel(lines, widthWorld, heightWorld, x, y, z, rotY) {
    const geo = new THREE.PlaneGeometry(widthWorld, heightWorld);
    const tex = createTextTexture(lines);
    const mat = new THREE.MeshStandardMaterial({
      map: tex,
      metalness: 0.4,
      roughness: 0.6,
      emissive: new THREE.Color(0x111122),
      emissiveIntensity: 0.4
    });
    const mesh = new THREE.Mesh(geo, mat);
    mesh.position.set(x, y, z);
    mesh.rotation.y = rotY;
    mesh.castShadow = true;
    mesh.receiveShadow = true;
    scene.add(mesh);
    addCollider(mesh);
    return mesh;
  }

  const leaderboardLines = [
    'Síň megalovců',
    '-----------------',
    ...leaderboard.map((d, i) => `${i + 1}. ${d.name} — ${d.score}`)
  ];
  createPanel(
    leaderboardLines,
    10,
    5.5,
    0,
    4.5,
    -roomDepth / 2 + 0.35,
    0
  );

  createPanel(
    hallOfFame,
    6.5,
    4.2,
    -roomWidth / 2 + 0.35,
    4.2,
    -6,
    Math.PI / 2
  );

  createPanel(
    streaks,
    6.5,
    4.2,
    roomWidth / 2 - 0.35,
    4.2,
    -2,
    -Math.PI / 2
  );

  // ===== TROFEJE / PODSTAVCE =====
  const pedestalMat = new THREE.MeshStandardMaterial({
    color: 0x181820,
    metalness: 0.6,
    roughness: 0.35
  });

  function createPedestal(x, z, height = 1.4) {
    const geo = new THREE.CylinderGeometry(0.7, 0.9, height, 24);
    const mesh = new THREE.Mesh(geo, pedestalMat);
    mesh.position.set(x, height / 2, z);
    mesh.castShadow = true;
    mesh.receiveShadow = true;
    scene.add(mesh);
    addCollider(mesh);
    return mesh;
  }

  function createTrophy(x, z, color) {
    const geo = new THREE.SphereGeometry(0.45, 32, 32);
    const mat = new THREE.MeshStandardMaterial({
      color: 0xffffff,
      emissive: new THREE.Color(color),
      emissiveIntensity: 1.8,
      metalness: 0.9,
      roughness: 0.15
    });
    const mesh = new THREE.Mesh(geo, mat);
    mesh.position.set(x, 2.2, z);
    mesh.castShadow = true;
    scene.add(mesh);
    return mesh;
  }

  createPedestal(-4, 1);
  createPedestal(4, 1);
  createPedestal(0, -5);

  const trophy1 = createTrophy(-4, 1, 0xffd700);
  const trophy2 = createTrophy(4, 1, 0x44ddff);
  const trophy3 = createTrophy(0, -5, 0xaa66ff);

  // ===== CENTRÁLNÍ KOTLÍK S OHNĚM =====
  const cauldronMat = new THREE.MeshStandardMaterial({
    color: 0x202020,
    metalness: 0.7,
    roughness: 0.4
  });

  const cauldronGeo = new THREE.CylinderGeometry(1.1, 1.4, 0.9, 32, 1, false);
  const cauldron = new THREE.Mesh(cauldronGeo, cauldronMat);
  cauldron.position.set(0, 0.45, 0);
  cauldron.castShadow = true;
  cauldron.receiveShadow = true;
  scene.add(cauldron);
  addCollider(cauldron);

  const emberGeo = new THREE.SphereGeometry(0.18, 16, 16);
  const emberMat = new THREE.MeshStandardMaterial({
    color: 0xffaa55,
    emissive: new THREE.Color(0xff5500),
    emissiveIntensity: 2.0,
    metalness: 0.3,
    roughness: 0.4
  });

  const embers = [];
  for (let i = 0; i < 6; i++) {
    const m = new THREE.Mesh(emberGeo, emberMat);
    const angle = (i / 6) * Math.PI * 2;
    const r = 0.4 + Math.random() * 0.15;
    m.position.set(
      Math.cos(angle) * r,
      0.55 + Math.random() * 0.1,
      Math.sin(angle) * r
    );
    m.castShadow = true;
    scene.add(m);
    embers.push(m);
  }

  const flameMat = new THREE.SpriteMaterial({
    color: 0xffddaa,
    opacity: 0.9
  });
  const flame = new THREE.Sprite(flameMat);
  flame.scale.set(1.4, 2.4, 1);
  flame.position.set(0, 1.4, 0);
  scene.add(flame);

  const fireLight = new THREE.PointLight(0xffaa55, 1.8, 12);
  fireLight.position.set(0, 1.4, 0);
  scene.add(fireLight);

  // ===== OVLÁDÁNÍ – TOUR MÓD =====
  const controls = new PointerLockControls(camera, document.body);
  const overlay = document.getElementById('overlay');

  overlay.addEventListener('click', () => {
    controls.lock();
  });

  controls.addEventListener('lock', () => {
    overlay.style.display = 'none';
  });

  controls.addEventListener('unlock', () => {
    overlay.style.display = 'flex';
  });

  scene.add(controls.getObject());

  const playerHeight = 2.0;
  controls.getObject().position.set(0, playerHeight, roomDepth / 2 - 5);

  const velocity = new THREE.Vector3();
  const keyStates = {};
  const moveSpeed = 4.0;

  document.addEventListener('keydown', (e) => {
    keyStates[e.code] = true;
  });
  document.addEventListener('keyup', (e) => {
    keyStates[e.code] = false;
  });

  function getForwardVector() {
    const forward = new THREE.Vector3();
    camera.getWorldDirection(forward);
    forward.y = 0;
    forward.normalize();
    return forward;
  }

  function getSideVector() {
    const side = new THREE.Vector3();
    camera.getWorldDirection(side);
    side.y = 0;
    side.normalize();
    side.cross(camera.up);
    return side;
  }

  function resolveCollisions(newPos) {
    const playerRadius = 0.6;

    for (let i = 0; i < colliderBoxes.length; i++) {
      const box = colliderBoxes[i];

      const closest = new THREE.Vector3(
        THREE.MathUtils.clamp(newPos.x, box.min.x, box.max.x),
        THREE.MathUtils.clamp(newPos.y, box.min.y, box.max.y),
        THREE.MathUtils.clamp(newPos.z, box.min.z, box.max.z)
      );

      const dist = closest.distanceTo(newPos);

      if (dist < playerRadius) {
        const push = newPos.clone().sub(closest).setY(0).normalize();
        const depth = playerRadius - dist;
        newPos.addScaledVector(push, depth);
      }
    }
  }

  function handleMovement(delta) {
    if (!controls.isLocked) return;

    velocity.x *= 0.85;
    velocity.z *= 0.85;

    const forward = getForwardVector();
    const side = getSideVector();

    if (keyStates['KeyW']) velocity.addScaledVector(forward, moveSpeed * delta);
    if (keyStates['KeyS']) velocity.addScaledVector(forward, -moveSpeed * delta);
    if (keyStates['KeyA']) velocity.addScaledVector(side, -moveSpeed * delta);
    if (keyStates['KeyD']) velocity.addScaledVector(side, moveSpeed * delta);

    const oldPos = controls.getObject().position.clone();
    const newPos = oldPos.clone().addScaledVector(velocity, 1);

    const halfWidth = roomWidth / 2 - 0.8;
    const halfDepth = roomDepth / 2 - 0.8;

    if (newPos.x < -halfWidth) newPos.x = -halfWidth;
    if (newPos.x > halfWidth) newPos.x = halfWidth;
    if (newPos.z < -halfDepth) newPos.z = -halfDepth;
    if (newPos.z > halfDepth) newPos.z = halfDepth;

    resolveCollisions(newPos);

    newPos.y = playerHeight;
    controls.getObject().position.copy(newPos);
  }

  // ===== ANIMACE =====
  const clock = new THREE.Clock();

  function animate() {
    requestAnimationFrame(animate);
    const delta = clock.getDelta();
    const t = clock.getElapsedTime();

    handleMovement(delta);

    trophy1.rotation.y = t * 0.4;
    trophy2.rotation.y = -t * 0.35;
    trophy3.rotation.y = t * 0.5;

    flame.material.opacity = 0.8 + Math.sin(t * 6.0) * 0.15;
    flame.position.y = 1.4 + Math.sin(t * 3.0) * 0.05;
    fireLight.intensity = 1.6 + Math.sin(t * 8.0) * 0.3;

    embers.forEach((e, i) => {
      e.position.y = 0.55 + Math.sin(t * 3 + i) * 0.05;
    });

    renderer.render(scene, camera);
  }

  animate();

  // ===== RESIZE =====
  window.addEventListener('resize', () => {
    camera.aspect = window.innerWidth / window.innerHeight;
    camera.updateProjectionMatrix();
    renderer.setSize(window.innerWidth, window.innerHeight);
  });
</script>
</body>
</html>