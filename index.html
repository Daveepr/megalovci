<!DOCTYPE html>
<html lang="cs">
<head>
  <meta charset="UTF-8">
  <title>Síň megalovců 3D – základní místnost</title>
  <style>
    body {
      margin: 0;
      overflow: hidden;
      background: #000;
      font-family: system-ui, sans-serif;
    }
    #overlay {
      position: fixed;
      inset: 0;
      display: flex;
      align-items: center;
      justify-content: center;
      background: rgba(0,0,0,0.85);
      color: #fff;
      cursor: pointer;
      z-index: 10;
      flex-direction: column;
      text-align: center;
    }
    #hint {
      position: fixed;
      top: 10px;
      left: 10px;
      padding: 6px 10px;
      font-size: 13px;
      color: #eee;
      background: rgba(0,0,0,0.55);
      border-radius: 4px;
      z-index: 5;
    }
  </style>
</head>
<body>

<div id="overlay">
  <h1>SÍŇ MEGALOVCŮ</h1>
  <p>Klikni pro vstup. Ovládání: WASD + myš, 1/2/3 = světelné režimy</p>
</div>
<div id="hint">
  WASD + myš • 1 = den • 2 = ambient • 3 = 13. století
</div>

<script type="module">
import * as THREE from './three.module.js';
import { PointerLockControls } from './PointerLockControls.js';

/* ============================================================
   SCÉNA
============================================================ */
const scene = new THREE.Scene();
scene.background = new THREE.Color(0x050407);
scene.fog = new THREE.FogExp2(0x050407, 0.03);

const camera = new THREE.PerspectiveCamera(
  70,
  window.innerWidth / window.innerHeight,
  0.1,
  200
);

const renderer = new THREE.WebGLRenderer({ antialias: true });
renderer.setSize(window.innerWidth, window.innerHeight);
renderer.shadowMap.enabled = true;
renderer.shadowMap.type = THREE.PCFSoftShadowMap;
document.body.appendChild(renderer.domElement);

/* ============================================================
   ROZMĚRY MÍSTNOSTI
============================================================ */
const roomWidth = 26;
const roomDepth = 32;
const roomHeight = 9;

/* ============================================================
   TEXTURY
============================================================ */
const loader = new THREE.TextureLoader();

function tex(path, repX, repY) {
  const t = loader.load(path);
  t.wrapS = t.wrapT = THREE.RepeatWrapping;
  t.repeat.set(repX, repY);
  t.anisotropy = renderer.capabilities.getMaxAnisotropy();
  return t;
}

// opakování zvolené tak, aby nic nebylo natažené
const texFloor  = tex('./grf/podlaha.jpg',   6, 6);
const texWall   = tex('./grf/stena.jpg',     5, 3);
const texBottom = tex('./grf/stenadole.jpg', 6, 2);
const texCeil   = tex('./grf/strop.jpg',     4, 4);

/* ============================================================
   MATERIÁLY
============================================================ */
const matFloor = new THREE.MeshStandardMaterial({
  map: texFloor,
  metalness: 0.3,
  roughness: 0.4
});

const matWall = new THREE.MeshStandardMaterial({
  map: texWall,
  metalness: 0.1,
  roughness: 0.75
});

const matBottom = new THREE.MeshStandardMaterial({
  map: texBottom,
  metalness: 0.1,
  roughness: 0.8
});

const matCeil = new THREE.MeshStandardMaterial({
  map: texCeil,
  metalness: 0.05,
  roughness: 0.9
});

/* ============================================================
   SVĚTLA – základní instance
============================================================ */
const hemi = new THREE.HemisphereLight(0xfff0d0, 0x201010, 0.6);
scene.add(hemi);

const mainSpot = new THREE.SpotLight(0xffffff, 1.3, 120, Math.PI/4, 0.4);
mainSpot.position.set(0, 15, 0);
mainSpot.castShadow = true;
scene.add(mainSpot);

const warm = new THREE.PointLight(0xffbb66, 0.8, 40);
warm.position.set(-10, 5, -10);
scene.add(warm);

const cool = new THREE.PointLight(0x6688ff, 0.5, 40);
cool.position.set(10, 5, -10);
scene.add(cool);

const floorGlow = new THREE.PointLight(0xffddaa, 0.4, 25);
floorGlow.position.set(0, 1.0, 0);
scene.add(floorGlow);

/* ============================================================
   KOLIZNÍ SYSTÉM
============================================================ */
const colliders = [];
const colliderBoxes = [];

function addCollider(mesh) {
  colliders.push(mesh);
  colliderBoxes.push(new THREE.Box3().setFromObject(mesh));
}

function updateColliders() {
  for (let i = 0; i < colliders.length; i++) {
    colliderBoxes[i].setFromObject(colliders[i]);
  }
}

/* ============================================================
   PODLAHA
============================================================ */
const floor = new THREE.Mesh(
  new THREE.PlaneGeometry(roomWidth, roomDepth),
  matFloor
);
floor.rotation.x = -Math.PI / 2;
floor.receiveShadow = true;
scene.add(floor);

/* ============================================================
   STROP
============================================================ */
const ceiling = new THREE.Mesh(
  new THREE.PlaneGeometry(roomWidth, roomDepth),
  matCeil
);
ceiling.rotation.x = Math.PI / 2;
ceiling.position.y = roomHeight;
ceiling.receiveShadow = true;
scene.add(ceiling);

/* ============================================================
   STĚNY – dvě části: spodní lem + horní tapeta
============================================================ */
function createWall(width, height, depth, x, y, z, rotY = 0) {
  const bottomH = height * 0.10;
  const topH = height - bottomH;

  // spodní lem
  const bottom = new THREE.Mesh(
    new THREE.BoxGeometry(width, bottomH, depth),
    matBottom
  );
  bottom.position.set(x, y - topH/2, z);
  bottom.rotation.y = rotY;
  bottom.castShadow = true;
  bottom.receiveShadow = true;
  scene.add(bottom);
  addCollider(bottom);

  // horní tapeta
  const top = new THREE.Mesh(
    new THREE.BoxGeometry(width, topH, depth),
    matWall
  );
  top.position.set(x, y + bottomH/2, z);
  top.rotation.y = rotY;
  top.castShadow = true;
  top.receiveShadow = true;
  scene.add(top);
  addCollider(top);
}

// obvod
createWall(roomWidth, roomHeight, 0.6, 0, roomHeight/2, -roomDepth/2);
createWall(roomWidth, roomHeight, 0.6, 0, roomHeight/2,  roomDepth/2);
createWall(roomDepth, roomHeight, 0.6, -roomWidth/2, roomHeight/2, 0, Math.PI/2);
createWall(roomDepth, roomHeight, 0.6,  roomWidth/2, roomHeight/2, 0, Math.PI/2);

updateColliders();

/* ============================================================
   OVLÁDÁNÍ – PointerLock
============================================================ */
const controls = new PointerLockControls(camera, document.body);
const overlay = document.getElementById('overlay');

overlay.addEventListener('click', () => controls.lock());
controls.addEventListener('lock', () => overlay.style.display = 'none');
controls.addEventListener('unlock', () => overlay.style.display = 'flex');

scene.add(controls.getObject());
controls.getObject().position.set(0, 2, roomDepth/2 - 5);

/* ============================================================
   LOUČ – světlo u hráče (pro režim 3)
============================================================ */
const torchLight = new THREE.PointLight(0xffaa55, 0, 10);
torchLight.position.set(0, 1.8, 0);
controls.getObject().add(torchLight);

/* ============================================================
   SVĚTELNÉ PRESETY
============================================================ */
const lightPresets = {
  day: {
    hemi: 0.9,
    main: 1.6,
    warm: 1.0,
    cool: 0.8,
    ambient: 0.4
  },
  ambient: {
    hemi: 0.4,
    main: 0.7,
    warm: 0.6,
    cool: 0.4,
    ambient: 0.2
  },
  medieval: {
    hemi: 0.05,
    main: 0.0,
    warm: 0.0,
    cool: 0.0,
    ambient: 0.0
  }
};

function applyLightPreset(preset) {
  const target = lightPresets[preset];
  const duration = 0.6;

  const start = {
    hemi: hemi.intensity,
    main: mainSpot.intensity,
    warm: warm.intensity,
    cool: cool.intensity,
    ambient: floorGlow.intensity,
    torch: torchLight.intensity
  };

  const end = {
    hemi: target.hemi,
    main: target.main,
    warm: target.warm,
    cool: target.cool,
    ambient: target.ambient,
    torch: preset === 'medieval' ? 1.4 : 0
  };

  let t = 0;
  function fade() {
    t += 0.02;
    const k = Math.min(t / duration, 1);

    hemi.intensity      = start.hemi   + (end.hemi   - start.hemi)   * k;
    mainSpot.intensity  = start.main   + (end.main   - start.main)   * k;
    warm.intensity      = start.warm   + (end.warm   - start.warm)   * k;
    cool.intensity      = start.cool   + (end.cool   - start.cool)   * k;
    floorGlow.intensity = start.ambient+ (end.ambient- start.ambient)* k;
    torchLight.intensity= start.torch  + (end.torch  - start.torch)  * k;

    if (k < 1) requestAnimationFrame(fade);
  }
  fade();
}

// výchozí režim – ambient
applyLightPreset('ambient');

/* ============================================================
   OVLÁDÁNÍ KLAEVSAMI – přepínání světel
============================================================ */
const key = {};
document.addEventListener('keydown', (e) => {
  key[e.code] = true;

  if (e.code === 'Digit1') applyLightPreset('day');
  if (e.code === 'Digit2') applyLightPreset('ambient');
  if (e.code === 'Digit3') applyLightPreset('medieval');
});
document.addEventListener('keyup', (e) => {
  key[e.code] = false;
});

/* ============================================================
   POHYB HRÁČE
============================================================ */
const velocity = new THREE.Vector3();
const speed = 4.0;

function forwardVec() {
  const v = new THREE.Vector3();
  camera.getWorldDirection(v);
  v.y = 0;
  return v.normalize();
}

function sideVec() {
  const v = new THREE.Vector3();
  camera.getWorldDirection(v);
  v.y = 0;
  v.normalize();
  v.cross(camera.up);
  return v;
}

function resolveCollisions(newPos, oldPos) {
  const r = 0.6;
  const steps = 4;
  const step = new THREE.Vector3().subVectors(newPos, oldPos).divideScalar(steps);
  const temp = oldPos.clone();

  for (let s = 0; s < steps; s++) {
    temp.add(step);

    for (let i = 0; i < colliderBoxes.length; i++) {
      const box = colliderBoxes[i];
      const closest = new THREE.Vector3(
        THREE.MathUtils.clamp(temp.x, box.min.x, box.max.x),
        THREE.MathUtils.clamp(temp.y, box.min.y, box.max.y),
        THREE.MathUtils.clamp(temp.z, box.min.z, box.max.z)
      );
      const dist = closest.distanceTo(temp);
      if (dist < r) {
        const push = temp.clone().sub(closest).setY(0).normalize();
        temp.addScaledVector(push, r - dist);
      }
    }
  }
  return temp;
}

function move(delta) {
  if (!controls.isLocked) return;

  velocity.x *= 0.85;
  velocity.z *= 0.85;

  if (key['KeyW']) velocity.addScaledVector(forwardVec(), speed * delta);
  if (key['KeyS']) velocity.addScaledVector(forwardVec(), -speed * delta);
  if (key['KeyA']) velocity.addScaledVector(sideVec(), -speed * delta);
  if (key['KeyD']) velocity.addScaledVector(sideVec(),  speed * delta);

  const oldPos = controls.getObject().position.clone();
  let newPos = oldPos.clone().addScaledVector(velocity, 1);

  const hw = roomWidth/2 - 0.8;
  const hd = roomDepth/2 - 0.8;

  newPos.x = THREE.MathUtils.clamp(newPos.x, -hw, hw);
  newPos.z = THREE.MathUtils.clamp(newPos.z, -hd, hd);

  newPos = resolveCollisions(newPos, oldPos);
  newPos.y = 2;

  controls.getObject().position.copy(newPos);
}

/* ============================================================
   ANIMACE
============================================================ */
const clock = new THREE.Clock();

function animate() {
  requestAnimationFrame(animate);
  const delta = clock.getDelta();
  move(delta);
  renderer.render(scene, camera);
}
animate();

/* ============================================================
   RESIZE
============================================================ */
window.addEventListener('resize', () => {
  camera.aspect = window.innerWidth / window.innerHeight;
  camera.updateProjectionMatrix();
  renderer.setSize(window.innerWidth, window.innerHeight);
});
</script>
</body>
</html>