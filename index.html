<!DOCTYPE html>
<html lang="cs">
<head>
  <meta charset="UTF-8">
  <title>Síň megalovců 3D – Čistá místnost</title>
  <style>
    body {
      margin: 0;
      overflow: hidden;
      background: #000;
      font-family: system-ui, sans-serif;
    }
    #overlay {
      position: fixed;
      inset: 0;
      display: flex;
      align-items: center;
      justify-content: center;
      background: rgba(0,0,0,0.85);
      color: #fff;
      cursor: pointer;
      z-index: 10;
      flex-direction: column;
      text-align: center;
    }
  </style>
</head>
<body>

<div id="overlay">
  <h1>SÍŇ MEGALOVCŮ</h1>
  <p>Klikni pro vstup. Ovládání: WASD + myš</p>
</div>

<script type="module">
import * as THREE from './three.module.js';
import { PointerLockControls } from './PointerLockControls.js';

/* ============================================================
   SCÉNA
============================================================ */
const scene = new THREE.Scene();
scene.background = new THREE.Color(0x050407);
scene.fog = new THREE.FogExp2(0x050407, 0.03);

const camera = new THREE.PerspectiveCamera(
  70,
  window.innerWidth / window.innerHeight,
  0.1,
  200
);

const renderer = new THREE.WebGLRenderer({ antialias: true });
renderer.setSize(window.innerWidth, window.innerHeight);
renderer.shadowMap.enabled = true;
renderer.shadowMap.type = THREE.PCFSoftShadowMap;
document.body.appendChild(renderer.domElement);

/* ============================================================
   SVĚTLA – teplá galerijní atmosféra
============================================================ */
const hemi = new THREE.HemisphereLight(0xfff0d0, 0x201010, 0.55);
scene.add(hemi);

const mainSpot = new THREE.SpotLight(0xffffff, 1.3, 120, Math.PI/4, 0.4);
mainSpot.position.set(0, 15, 0);
mainSpot.castShadow = true;
scene.add(mainSpot);

const warm = new THREE.PointLight(0xffbb66, 0.8, 40);
warm.position.set(-10, 5, -10);
scene.add(warm);

const cool = new THREE.PointLight(0x6688ff, 0.5, 40);
cool.position.set(10, 5, -10);
scene.add(cool);

/* ============================================================
   ROZMĚRY MÍSTNOSTI
============================================================ */
const roomWidth = 26;
const roomDepth = 32;
const roomHeight = 9;

/* ============================================================
   TEXTURY (lokální, bez zvětšování)
============================================================ */
const loader = new THREE.TextureLoader();

function tex(path, repX, repY) {
  const t = loader.load(path);
  t.wrapS = t.wrapT = THREE.RepeatWrapping;
  t.repeat.set(repX, repY);
  t.anisotropy = renderer.capabilities.getMaxAnisotropy();
  return t;
}

const texFloor  = tex('./grf/podlaha.jpg',   4, 4);
const texWall   = tex('./grf/stena.jpg',     3, 2);
const texBottom = tex('./grf/stenadole.jpg', 3, 1);
const texCeil   = tex('./grf/strop.jpg',     3, 3);

/* ============================================================
   MATERIÁLY
============================================================ */
const matFloor = new THREE.MeshStandardMaterial({
  map: texFloor,
  metalness: 0.3,
  roughness: 0.4
});

const matWall = new THREE.MeshStandardMaterial({
  map: texWall,
  metalness: 0.1,
  roughness: 0.75
});

const matBottom = new THREE.MeshStandardMaterial({
  map: texBottom,
  metalness: 0.1,
  roughness: 0.8
});

const matCeil = new THREE.MeshStandardMaterial({
  map: texCeil,
  metalness: 0.2,
  roughness: 0.6
});

/* ============================================================
   KOLIZNÍ SYSTÉM
============================================================ */
const colliders = [];
const colliderBoxes = [];

function addCollider(mesh) {
  colliders.push(mesh);
  colliderBoxes.push(new THREE.Box3().setFromObject(mesh));
}

function updateColliders() {
  for (let i = 0; i < colliders.length; i++) {
    colliderBoxes[i].setFromObject(colliders[i]);
  }
}

/* ============================================================
   PODLAHA
============================================================ */
const floor = new THREE.Mesh(
  new THREE.PlaneGeometry(roomWidth, roomDepth),
  matFloor
);
floor.rotation.x = -Math.PI / 2;
floor.receiveShadow = true;
scene.add(floor);

/* ============================================================
   STROP
============================================================ */
const ceiling = new THREE.Mesh(
  new THREE.PlaneGeometry(roomWidth, roomDepth),
  matCeil
);
ceiling.rotation.x = Math.PI / 2;
ceiling.position.y = roomHeight;
ceiling.receiveShadow = true;
scene.add(ceiling);

/* ============================================================
   STĚNY – varianta 1 (dvě části: spodní lem + horní tapeta)
============================================================ */
function createWall(width, height, depth, x, y, z, rotY = 0) {
  const bottomH = height * 0.13;
  const topH = height - bottomH;

  // spodní lem
  const bottom = new THREE.Mesh(
    new THREE.BoxGeometry(width, bottomH, depth),
    matBottom
  );
  bottom.position.set(x, y - topH/2, z);
  bottom.rotation.y = rotY;
  bottom.castShadow = true;
  bottom.receiveShadow = true;
  scene.add(bottom);
  addCollider(bottom);

  // horní tapeta
  const top = new THREE.Mesh(
    new THREE.BoxGeometry(width, topH, depth),
    matWall
  );
  top.position.set(x, y + bottomH/2, z);
  top.rotation.y = rotY;
  top.castShadow = true;
  top.receiveShadow = true;
  scene.add(top);
  addCollider(top);
}

// obvod
createWall(roomWidth, roomHeight, 0.6, 0, roomHeight/2, -roomDepth/2);
createWall(roomWidth, roomHeight, 0.6, 0, roomHeight/2,  roomDepth/2);
createWall(roomDepth, roomHeight, 0.6, -roomWidth/2, roomHeight/2, 0, Math.PI/2);
createWall(roomDepth, roomHeight, 0.6,  roomWidth/2, roomHeight/2, 0, Math.PI/2);

updateColliders();

/* ============================================================
   OVLÁDÁNÍ – PointerLock
============================================================ */
const controls = new PointerLockControls(camera, document.body);
document.getElementById('overlay').addEventListener('click', () => controls.lock());
controls.addEventListener('lock', () => document.getElementById('overlay').style.display = 'none');
controls.addEventListener('unlock', () => document.getElementById('overlay').style.display = 'flex');
scene.add(controls.getObject());

controls.getObject().position.set(0, 2, roomDepth/2 - 5);

const velocity = new THREE.Vector3();
const key = {};
const speed = 4.0;

document.addEventListener('keydown', e => key[e.code] = true);
document.addEventListener('keyup',   e => key[e.code] = false);

function forwardVec() {
  const v = new THREE.Vector3();
  camera.getWorldDirection(v);
  v.y = 0;
  return v.normalize();
}

function sideVec() {
  const v = new THREE.Vector3();
  camera.getWorldDirection(v);
  v.y = 0;
  v.normalize();
  v.cross(camera.up);
  return v;
}

function resolveCollisions(newPos, oldPos) {
  const r = 0.6;
  const steps = 4;
  const step = new THREE.Vector3().subVectors(newPos, oldPos).divideScalar(steps);
  const temp = oldPos.clone();

  for (let s = 0; s < steps; s++) {
    temp.add(step);

    for (let i = 0; i < colliderBoxes.length; i++) {
      const box = colliderBoxes[i];
      const closest = new THREE.Vector3(
        THREE.MathUtils.clamp(temp.x, box.min.x, box.max.x),
        THREE.MathUtils.clamp(temp.y, box.min.y, box.max.y),
        THREE.MathUtils.clamp(temp.z, box.min.z, box.max.z)
      );
      const dist = closest.distanceTo(temp);
      if (dist < r) {
        const push = temp.clone().sub(closest).setY(0).normalize();
        temp.addScaledVector(push, r - dist);
      }
    }
  }
  return temp;
}

function move(delta) {
  if (!controls.isLocked) return;

  velocity.x *= 0.85;
  velocity.z *= 0.85;

  if (key['KeyW']) velocity.addScaledVector(forwardVec(), speed * delta);
  if (key['KeyS']) velocity.addScaledVector(forwardVec(), -speed * delta);
  if (key['KeyA']) velocity.addScaledVector(sideVec(), -speed * delta);
  if (key['KeyD']) velocity.addScaledVector(sideVec(),  speed * delta);

  const oldPos = controls.getObject().position.clone();
  let newPos = oldPos.clone().addScaledVector(velocity, 1);

  const hw = roomWidth/2 - 0.8;
  const hd = roomDepth/2 - 0.8;

  newPos.x = THREE.MathUtils.clamp(newPos.x, -hw, hw);
  newPos.z = THREE.MathUtils.clamp(newPos.z, -hd, hd);

  newPos = resolveCollisions(newPos, oldPos);
  newPos.y = 2;

  controls.getObject().position.copy(newPos);
}

/* ============================================================
   ANIMACE
============================================================ */
const clock = new THREE.Clock();

function animate() {
  requestAnimationFrame(animate);
  move(clock.getDelta());
  renderer.render(scene, camera);
}
animate();

/* ============================================================
   RESIZE
============================================================ */
window.addEventListener('resize', () => {
  camera.aspect = window.innerWidth / window.innerHeight;
  camera.updateProjectionMatrix();
  renderer.setSize(window.innerWidth, window.innerHeight);
});
</script>
</body>
</html>